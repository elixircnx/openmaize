defmodule Openmaize.OnetimePass do
  @moduledoc """
  Module to handle one-time passwords for use in two factor authentication.

  There is one option to set the database module used:

    * db_module - the module that is used to query the database
      * the default is MyApp.OpenmaizeEcto - the name of the module generated by `mix openmaize.gen.ectodb`
      * if you implement your own database module, it needs to implement the Openmaize.Database behaviour

  There are also the following options for the one-time passwords:

    * HMAC-based one-time passwords
      * token_length - the length of the one-time password
        * the default is 6
      * last - the count when the one-time password was last used
        * this count needs to be stored server-side
      * window - the number of future attempts allowed
        * the default is 3
    * Time-based one-time passwords
      * token_length - the length of the one-time password
        * the default is 6
      * interval_length - the length of each timed interval
        * the default is 30 (seconds)
      * window - the number of attempts, before and after the current one, allowed
        * the default is 1 (1 interval before and 1 interval after)
        * you might need to increase this window to allow for clock skew on the server

  See the documentation for the Comeonin.Otp module for more details
  about generating and verifying one-time passwords.

  ## Examples

  Add the following line to your controller to call OnetimePass with the
  default values:

      plug Openmaize.OnetimePass when action in [:login_twofa]

  And to set the token length to 8 characters:

      plug Openmaize.OnetimePass, [token_length: 8] when action in [:login_twofa]


Support for enable/disable multiple logins with the same OTP

  * Why
    OTP Tokens shouldn't be never used again after their first validation, to prevent security holes. 
    If a TOTP token is allowed to be used multiple times during it's lifetime, a man-in-the-middle 
    attacker could use the eavesdropped token at the same time with the legitimate user, 
    gaining access to the service but without the user nor the administrator can notice the fact.
    An OTP already used should be rejected, and the user alerted with an informative message saying 
    to wait for the next token before entering again. The service administrator could 
    log all the multiple attempts, and point out those access with the same token 
    but coming from different IP.
  
  * How does it address the problem
    It adds a new item named :allow_multiple_otp_logins to the configuration file. 
    When its value is false (default), the database is checked every time the user try 
    to login with a valid OTP token. If the OTP token is already present in the database, 
    the token is rejected and the login will fail. 
    Instead if the valid token was never used before, it is stored in the database, 
    and the login will succeed.
  
  * Side effects
    The database is updated every time a token is valid and never used before.

  """

  @behaviour Plug

  import Plug.Conn
  alias Comeonin.Otp
  alias Openmaize.Config

  def init(opts) do
    Keyword.pop opts, :db_module, Openmaize.Utils.default_db
  end

  @doc """
  Handle the one-time password POST request.

  If the one-time password check is successful, the user will be added
  to the session.
  """
  def call(%Plug.Conn{params: %{"user" => %{"id" => id} = user_params}} = conn,
   {db_module, opts}) do
    db_module.find_user_by_id(id)
    |> check_key(user_params, opts)
    |> handle_store_token(user_params, db_module, Config.allow_multiple_otp_logins)
    |> handle_auth(conn)
  end

  defp check_key(user, %{"hotp" => hotp}, opts) do
    {user, Otp.check_hotp(hotp, user.otp_secret, opts)}
  end
  defp check_key(user, %{"totp" => totp}, opts) do
    {user, Otp.check_totp(totp, user.otp_secret, opts)}
  end




  @doc """
  Prevent the reuse of the totp token, when Config.allow_multiple_otp_logins is set to false.
  If the totp token is used for the first time, the token is stored 
  in the database, else return failure.
  """
  def handle_store_token({user, last}, %{"id" =>  user_id, "totp" => otp}, db_module, allow_multiple_otp_logins) do
    do_handle_store_token({user, last}, %{id: user_id, otp: otp}, db_module, allow_multiple_otp_logins)
  end
  @doc """
  The one-time password check (Otp.check_totp) failed, so doesn't store the token
  """
  def handle_store_token({user, false}, %{"id" =>  _user_id, "totp" => _otp}, _db_module, _ ) do
    {user, false}
  end

  @doc """
  Prevent the reuse of the totp token, when Config.allow_multiple_otp_logins is set to false.
  If the hotp token is used for the first time, the token is stored 
  in the database, else return failure.
  """
  def handle_store_token({user, last}, %{"id" =>  user_id, "hotp" => otp}, db_module, allow_multiple_otp_logins) do
    do_handle_store_token({user, last}, %{id: user_id, otp: otp}, db_module, allow_multiple_otp_logins)
  end
  @doc """
  The one-time password check (Otp.check_totp) failed, so doesn't store the token
  """
  def handle_store_token({user, false}, %{"id" =>  _user_id, "hotp" => _hotp}, _db_module, _ ) do
    {user, false}
  end

  defp do_handle_store_token({user, last}, %{:id =>  user_id, :otp => otp}, db_module, allow_multiple_otp_logins) when allow_multiple_otp_logins == false do 
    case db_module.old_otp_token?(user_id, otp) do
      :is_new ->
        # never used before, store it in the database
        db_module.add_token_to_old_tokens(user_id, otp)
        {user, last}
      :is_old ->
        # already in the database
        {user, false}
    end
  end
  defp do_handle_store_token({user, last}, %{:id =>  _user_id, :otp => _otp}, _db_module, allow_multiple_otp_logins) when allow_multiple_otp_logins == true do
    {user, last}
  end



  defp handle_auth({_, false}, conn) do
    put_private(conn, :openmaize_error, "Invalid credentials")
  end
  defp handle_auth({user, last}, conn) do
    put_private(conn, :openmaize_user, Map.put(user, :last, last))
  end
end
